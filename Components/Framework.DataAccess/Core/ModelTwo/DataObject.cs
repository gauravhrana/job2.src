using System;
using System.Collections.Generic;
using System.Text;
using System.Data.SqlClient;
using Framework.CommonServices.Utils;

namespace Framework.PM.Common.BusinessDomain
{
	/// <summary>
	/// base class of all simple data objects.  These can be thought of as lightweight typed datasets,
	/// supporting minimal functionality for loading and saving data and are ideal in a situation where
	/// you must quickly load data and dispose of it in one short term operation.  Typed data sets would be better if the 
	/// object must remain in memory and be repeatedly queried
	/// 
	/// Subclasses can be easily created and maintained using the MyGeneration MiddleTier autocode template.  
	/// These autogenerated objects have methods to instantiate from DataRow and SqlDataReader objects,
	/// perform insert/update operations & deep copies, etc in just a few lines of code
	/// </summary>
	[Serializable]
	public class DataObject
	{
		private static Dictionary<string, Dictionary<string, int>> _fields = new Dictionary<string, Dictionary<string, int>>();
		private static Dictionary<string, bool> _fieldsInitialized = new Dictionary<string, bool>();

		private DataObject _parent;

		private bool _dirty = false;
		private bool _delete = false;
		private bool _validate = false;

		public DataObject()
		{

		}

		/// <summary>
		/// creates a data object referencing a parent object (i.e. foreign key relationship)
		/// </summary>
		/// <param name="parent"></param>
		public DataObject(DataObject parent)
		{
			_parent = parent;
		}

		/// <summary>
		/// creates the data object from a SqlDataReader
		/// </summary>
		/// <param name="reader"></param>
		/// <param name="spName"></param>
		/// <param name="parent"></param>
		public DataObject(SqlDataReader reader, string spName, DataObject parent)
		{
			_parent = parent;
			Init(reader, spName);
		}

		/// <summary>
		/// reference to the parent object, or null if this is a root object
		/// </summary>
		public DataObject Parent
		{
			get { return _parent; }
		}

		/// <summary>
		/// maps to the primary key of the underlying table
		/// </summary>
		public virtual int PrimaryKey
		{
			get { return -1; }
		}

		/// <summary>
		/// gets/sets whether this object has been updated.  this property is
		/// updated by subclasses generated from the autocode template whenever a property dataChanges 
		/// in this object or any child DataObjects, and can be used to 
		/// easily detect if this object has uncommitted data
		/// </summary>
		public virtual bool Dirty
		{
			get { return _dirty; }
			set
			{
				_dirty = value;
				if (Parent != null)
				{
					Parent.Dirty = value;
				}
			}
		}

		/// <summary>
		/// gets whether this is a new object, not yet committed to the database
		/// </summary>
		public virtual bool New
		{
			get { return (PrimaryKey == -1); }
		}

		/// <summary>
		/// gets/sets whether this object has been marked for deletion
		/// </summary>
		public virtual bool Delete
		{
			get { return _delete; }
			set
			{
				if (value == true) Dirty = true;
				_delete = value;
			}
		}

		/// <summary>
		/// gets/sets whether this object should be validated at the server
		/// </summary>
		public virtual bool Validate
		{
			get { return _validate; }
			set { _validate = value; }
		}


		public static string GetString(object obj)
		{
			if (obj is DBNull)
				return String.Empty;
			return obj.ToString();
		}

		public static char GetChar(object obj)
		{
			if (obj is DBNull || obj.ToString() == "")
				return char.MinValue;

			return Convert.ToChar(obj);
		}

		public static char? GetNullableChar(object obj)
		{
			if (obj is DBNull || obj.ToString() == "")
				return null;

			return (char?)Convert.ToChar(obj);
		}

		public static double GetDouble(object obj)
		{
			if (obj is DBNull)
				return 0.0;

			return Convert.ToDouble(obj);
		}

		public static double? GetNullableDouble(object obj)
		{
			if (obj is DBNull)
				return null;

			return (double?)Convert.ToDouble(obj);
		}

		public static decimal GetDecimal(object obj)
		{
			if (obj is DBNull)
				return 0;

			return Convert.ToDecimal(obj);
		}

		public static decimal? GetNullableDecimal(object obj)
		{
			if (obj is DBNull)
				return null;

			return (decimal?)Convert.ToDecimal(obj);
		}

		public static int GetInt(object obj)
		{
			if (obj is DBNull)
				return 0;
			return Convert.ToInt32(obj);
		}

		public static int? GetNullableInt(object obj)
		{
			if (obj is DBNull)
				return null;

			return (int?)Convert.ToInt32(obj);
		}


		public static long GetLong(object obj)
		{
			if (obj is DBNull)
				return 0;
			return Convert.ToInt64(obj);
		}

		public static long? GetNullableLong(object obj)
		{
			if (obj is DBNull)
				return null;
			return (long?)Convert.ToInt64(obj);
		}

		public static DateTime GetDateTime(object obj)
		{
			if (obj is DBNull)
				return DateTime.MinValue;

			return Convert.ToDateTime(obj);
		}

		public static DateTime? GetNullableDateTime(object obj)
		{
			if (obj is DBNull)
				return null;
			return Convert.ToDateTime(obj);
		}


		public static DateTime GetDateFromDateID(object obj)
		{
			if (obj is DBNull)
				return DateTime.MinValue;

			return DateTimeUtils2.GetDateFromDateId(GetInt(obj));
		}

		public static bool GetBool(object obj)
		{
			if (obj is DBNull)
				return false;
			return Convert.ToInt16(obj) == 0 ? false : true;
		}

		public static bool? GetNullableBool(object obj)
		{
			if (obj is DBNull)
				return null;

			return (bool?)(Convert.ToInt16(obj) == 0 ? false : true);
		}


		public static string GetDBString(string s, bool nullable)
		{
			if (nullable && s.Trim() == String.Empty)
				return "null";
			else
			{
				s = s.Replace("'", "");
				return "'" + s + "'";
			}
		}

		public static string GetDBNumeric(double d, bool nullable)
		{
			if (nullable && d == 0)
				return "null";
			else
				return d.ToString();
		}

		public static string GetDBNumeric(decimal d, bool nullable)
		{
			if (nullable && d == 0)
				return "null";
			else
				return d.ToString();
		}

		public static string GetDBNumeric(int d, bool nullable)
		{
			if (nullable && d == 0)
				return "null";
			else
				return d.ToString();
		}

		public static string GetDBBool(bool b)
		{
			return (b) ? "1" : "0";
		}

		public static string GetDBDateID(DateTime dt, bool nullable)
		{
			if (nullable && dt == DateTime.MinValue)
				return "null";
			else
				return DateTimeUtils2.GetDateIdFromDateTime(dt).ToString();
		}

		/// <summary>
		/// gets name value pair of all properties of this object and their values. this can
		/// be used to create a list of stored procedure parameters for insert/update operations
		/// 
		/// Base implementation does nothing; this should be overridden in a subclass
		/// </summary>
		/// <returns></returns>
		public virtual KeyValuePair<string, object>[] GetParameters()
		{
			return new KeyValuePair<string, object>[0];
		}

		/// <summary>
		/// Initializes list of indices of result set fields for the given stored procedure
		/// this is called the first time a stored proc is executed so subsequent sp calls will
		/// yield optimal SqlDataReader read performance.  thus you can't use the same string
		/// for spName if the data object can be created by calling two different sp's
		/// </summary>
		/// <param name="reader"></param>
		/// <param name="spName">name of the stored proc</param>
		private static void Init(SqlDataReader reader, string spName)
		{

			if (!_fieldsInitialized.ContainsKey(spName))
			{
				lock (_fields)
				{

					if (!_fields.ContainsKey(spName)) _fields.Add(spName, new Dictionary<string, int>());
					for (var i = 0; i < reader.FieldCount; i++)
					{
						var fieldName = reader.GetName(i).ToUpper();
						if (!_fields[spName].ContainsKey(fieldName))
						{
							_fields[spName].Add(fieldName, i);
						}
					}
					if (_fieldsInitialized.ContainsKey(spName)) _fieldsInitialized.Add(spName, true);
				}
			}
		}

		/// <summary>
		/// gets the index of this field for a SqlDataReader for a given stored procedure
		/// </summary>
		/// <param name="spName">stored proc name</param>
		/// <param name="field">name of the field in the select clause</param>
		/// <returns></returns>
		protected int this[string spName, string field]
		{
			get
			{
				field = field.ToUpper();
				return (_fields.ContainsKey(spName) && _fields[spName].ContainsKey(field)) ? _fields[spName][field] : -1;
			}
		}

		/// <summary>
		/// checks how many levels deep we are in the parent/child hierarchy.  support a limited
		/// number of levels so infinite recursion doesn't occur with autocode object relationships
		/// </summary>
		/// <returns></returns>
		protected bool CheckRecursion()
		{
			#region implementation

			if (Parent == null) return true;
			if (Parent.Parent == null) return true;
			if (Parent.Parent.Parent == null) return true;
			if (Parent.Parent.Parent.Parent == null) return true;

			return false;

			#endregion
		}

	}
}
